#+title: Exercices 3

#+property: header-args :results output
#+exclude_tags: toc

* Table de matières :toc:
- [[#exercice-1-palindromes][Exercice 1: Palindromes]]
- [[#exercice-2-tri-par-insertion-récursif][Exercice 2: Tri par insertion récursif]]
  - [[#question-a][Question a:]]
  - [[#question-b][Question b:]]
  - [[#question-c][Question c:]]
- [[#exercice-3-tours-de-hanoï][Exercice 3: Tours de Hanoï]]
- [[#exercice-4-tri-fusion][Exercice 4: Tri fusion]]
  - [[#question-a-1][Question a:]]
  - [[#question-b-1][Question b:]]
- [[#exercice-5-chemins-dans-un-graphe][Exercice 5: Chemins dans un graphe]]
- [[#exercice-6-sous-listes-croissantes][Exercice 6: Sous-listes croissantes]]
  - [[#question-a-2][Question a:]]
  - [[#question-b-2][Question b:]]
  - [[#question-c-1][Question c:]]
  - [[#question-d][Question d:]]

* Exercice 1: Palindromes

Un palindrome est une chaîne de caractères qui reste la même lorsqu'on inverse l'ordre des caractères. Par exemple, /kayak/ et /elle/ sont des palindromes. On considère aussi que la chaîne vide ~""~ est un palindrome, et que toute chaîne à un seul caractère, comme par exemple ~"a"~ , est un palindrome. Écrire une fonction ~palindrome~ qui teste si une chaîne de caractères est un palindrome ou non.

#+begin_src python
def palindrome(c):
    if len(c) <= 1:
        return True
    else:
        return (c[0] == c[-1]) and palindrome(c[1:len(c)-1])
#+end_src

* Exercice 2: Tri par insertion récursif

Dans cet exercice, on va reformuler le tri par insertion comme un algorithme récursif. Dans un premier temps, on va considérer une version qui ne manipule pas la liste d'entrée ~L~, mais qui rend une nouvelle liste ~L_t~ triée contenant les mêmes entrées que ~L~.

** Question a:

Écrire une fonction ~inser(L,n)~, qui prend en entrée une liste ~L~, que l'on suppose triée, et un nombre ~n~, et renvoie la liste triée ~L_1~ obtenue en rajoutant ~n~ à ~L~.

#+begin_src python
def inser(L,n):
    L_1 = []
    i = 0
    while i < len(L) and L[i] < n:
        L_1.append(L[i])
        i += 1
    L_1.append(n)
    for i in range(i,len(L)):
        L_1.append(L[i])
    return L_1

print(inser([1,5,8,9],7))

#+end_src

** Question b:

Utiliser la fonction ~inser~ pour écrire une fonction récursive ~tri_insertion_rec~ qui implémente le tri par insertion.

#+begin_src python
def tri_insertion_rec(L):
    if len(L) == 0:
        return L
    else:
        return inser(tri_insertion_rec(L[0:len(L)-1]),L[len(L)-1])
#+end_src
** Question c:

Écrire une fonction récursive ~tri_insertion_rec_direct(L)~ qui trie directement la liste d'entrée ~L~.

* Exercice 3: Tours de Hanoï

Dans cet exercice, on va implémenter la solution récursive du jeu des /tours de Hanoï/ vue en cours.

La représentation du jeu est la suivante:

- Les trois piliers sont représentés par les caractères ~'A'~ , ~'B'~ et ~'C'~.
- Un nombre ~n~ représente le nombre de disques dans le jeu.

Écrire une fonction ~hanoi(n,P1,P2)~, qui prend en entrée le nombre ~n~ de piliers, le pilier de départ ~P1~ et d'arrivée ~P2~, et qui affiche une par une les instructions pour déplacer ~n~ piliers de ~P1~ vers ~P2~.

Par exemple, ~hanoi(3,'A','C')~ doit afficher:

#+begin_example
deplacer disque 1 de A vers C
deplacer disque 2 de A vers B
deplacer disque 1 de C vers B
deplacer disque 3 de A vers C
deplacer disque 1 de B vers A
deplacer disque 2 de B vers C
deplacer disque 1 de A vers C
#+end_example

* Exercice 4: Tri fusion

Cet exercice a pour but d'implémenter un algorithme de tri de type /diviser pour régner/; le *tri fusion*. Pour trier une liste ~L~, l'idée est la suivante:

- On découpe ~L~ en deux morceaux ~L1~ et ~L2~, et on les trie séparément.
- On fusionne les deux listes triées, afin d'obtenir un tri de la liste entière ~L~.

** Question a:

Écrire une fonction ~fusion~, qui prend en entrée deux listes _triées_ ~L1~ et ~L2~, et renvoie une liste triée ~L_fusion~ contenant les entrées de ~L1~ et ~L2~.

** Question b:

Utiliser la fonction ~fusion~ pour écrire une fonction ~tri_fusion~ qui implémente le tri fusion.

* Exercice 5: Chemins dans un graphe

Implémenter l'algorithme pour trouver le chemin le plus court dans un graphe, vu en cours.

* Exercice 6: Sous-listes croissantes

Si ~L~ est une liste de nombres, une /sous-liste croissante/ de ~L~ est donnée par une suite d'indices ~i_1 < i_2 ... < i_k~ tels que ~L[i_1] <= L[i_2] ... <= L[i_k]~. Le but de cet exercice est de construire un algorithme ~crois(L)~ qui trouve, pour une liste ~L~, la longueur de la sous-liste croissante la plus longue.

*Exemple*:

- ~L = [1,8,6,4,5,7,2,5]~
- sous-liste la plus longue: ~[1,4,5,7]~
- ~crois(L) == 4~

** Question a:

Pour un indice i de la liste, notons ~crois(L,i)~ la longueur de la sous-liste croissante la plus longue qui commence à l'indice i. Donner une formule pour ~crois(L)~ en termes des ~crois(L,i)~.

** Question b:

Notons I l'ensemble des indices j > i tels que L[j] >= L[i]. Donner une formule pour ~crois(L,i)~ en termes des ~crois(L,j)~, pour j \in I.

** Question c:

En déduire un algorithme récursif (diviser pour régner) pour calculer ~crois(L)~ et l'implémenter. Estimer sa complexité.

** Question d:

Implémenter un algorithme suivant une approche de programmation dynamique. Estimer sa complexité

# Local Variables:
# ispell-local-dictionary: "francais-tex"
# End:

#  LocalWords:  Hanoï Sous-listes sous-liste
